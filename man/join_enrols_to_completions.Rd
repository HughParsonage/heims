% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/join_enrols_to_completions.R
\name{join_enrols_to_completions}
\alias{join_enrols_to_completions}
\title{Join enrol to completion successively}
\usage{
join_enrols_to_completions(enrolTable, enrolYearById,
  enrol.id = "Enrol_Grattan_id", completionYearById,
  completion.id = "Completions_Grattan_id",
  completion.year = "completion_Year", completionTables, injective = FALSE,
  imatch = "imatch", keep_imatch = FALSE, debug = FALSE)
}
\arguments{
\item{enrolTable}{A data.table for enrolments (right table in the right outer joins)}

\item{enrolYearById}{Two-column data table: one column named the same as
\code{enrol.id}, which must be an integer column, and the other representing the enrolment year of that id.}

\item{enrol.id}{The unique identifier of each enrolment.}

\item{completionYearById}{Two-column data table: one column named the same as
\code{completion.id}, which must be an integer column, and the other representing the completion year of that id.}

\item{completion.id}{The unique identifier of each completion (possibly spread
over multiple tables).}

\item{completion.year}{The column in \code{completionTables} referring to the
year of completion.}

\item{completionTables}{A list. Each element contains two elements,
the first, \code{DT}, is a data.table, the second is passed to the
\code{on = } argument \code{data.table}. For example
\code{c("HE_Provider_name", "Student_id", "completion_Year>=enrol_Year")}
 for a non-equi join.}

\item{injective}{Does the join need to be injective? If \code{TRUE}, the result will be unique on \code{completion.id}, using the earliest match.}

\item{imatch}{Column name indicating the list element on which the successful join occurred.}

\item{keep_imatch}{Should the column \code{imatch} be present in the output?}

\item{debug}{Print intermediate tables.}
}
\description{
Join enrol to completion successively
}
